# Программирование на C и выполнение программ (Ответы)
## 1 Основы языка C
### 1.2 Основные правила вычислений

- _2/16 Первые примеры statement'ов_

А что выведется на экран при выполнении следующего кода? Напишите строчку в точности как она будет показана на экране.

```c
printf("Never");
printf("gonna");
printf(" give you up");
```
Подсказка: обратите внимание на пробелы! 

___Ответ:___
```c
Nevergonna give you up
```


---


- _3/16 Считаем выражения и выводим числа_

Напишите один statement, который выводит на экран результат сложения числа 17283 и произведения четырёх чисел: 5, 6, 7 и 8. Это пока ещё не полная программа, а только одно изолированное действие.

___Ответ:___
```c
printf("%d", 17283+5*6*7*8);
```


---


- _4/16_ 

Напишите определение функции с именем `print_newline`, которая переведёт вывод на новую строку, то есть выведет код "\n". Иначе говоря, создайте вашу первую функцию!

___Ответ:___
```c
void print_newline() {
    printf("\n");
}
```


---


- _6/16_

Представим, что мы уже определили несколько функций:
```c
void greet() {
    printf("Hello, ");
}

void b() {
    printf("Boris");
}

void v() {
    printf("Vladimir");
}

void print_newline() {
    printf("\n");
}
```
Вызывая эти функции, напечатайте на экран следующее:
```c
Hello, Boris
Hello, Vladimir
Hello, Boris
```
Пользоваться функцией `printf` напрямую в этом задании запрещено.

В текстовое поле нужно ввести только последовательность вызовов функций через точку с запятой (как будто мы внутри тела функции `main`).

Саму функцию `main` определять не нужно - не пытайтесь бездумно скопировать примеры полных программ из Интернета, напишите только последовательность вызовов функций.

___Ответ:___
```c
greet();
b();
print_newline();
greet();
v();
print_newline();
greet();
b();
print_newline();
```


---

- _11/16_
Вам дано определение функции:

```c
void greet( int n ) {
    printf("Hello ");
    printf("%d", n);
    printf("\n");
}
```
Вызывая функцию `greet` с разными аргументами, напечатайте на экран следующее:

```c
Hello 10
Hello 20
Hello 42
```
Пользоваться функцией `printf` напрямую в этом задании запрещено.

В ответе нужно просто вписать несколько вызовов функции greet с аргументами; не забудьте точку с запятой после каждого вызова!

___Ответ:___
```c
greet(10);
greet(20);
greet(42);
```


---

- _12/16 Функции с несколькими аргументами_

Теперь задание: напишите определение новой функции с именем `f`, которая принимает через аргументы два числа и печатает на экран их сумму с помощью `printf`.  В примере выше функция `print_int2` принимает два числа через аргументы и просто печатает их, а теперь нужно распечатать не числа по отдельности, а сложить их и распечатать результат.

___Ответ:___
```c
void f(int a, int b) {
    printf("%d", a + b);
}
```


---

- _15/16_

  Напишите функцию `avg3` с тремя аргументами, которая вернёт среднее арифметическое своих аргументов. Подразумевается использование целочисленного деления, т.е. среднее чисел 3, 6 и 10 будет 6, а не 6.3333...

То есть, достаточно сложить аргументы и поделить результат на их количество.

___Ответ:___
```c
int avg3(int a, int b, int c) {
    return (a+b+c)/3;
}
```

---

---

---


### 1.3 Основные правила вычислений

- _2/15 Последовательные проверки_

А что выведет этот код?
```c
int a = 10;
if (a > 5) { printf("1"); }
if (a > 8) { printf("2"); }
if (a > 3) { printf("3"); }
```

___Ответ:___
```
123
```


---

- _3/15 Вложенные условия_

Что выведется в результате выполнения этого кода?
```c
int a = 10;
if (a > 5) { printf("9"); }
else {
    if (a > 8) { printf("2"); }
    if (a > 3) { printf("3"); }
}
```

___Ответ:___
```
9
```


---

- _5/15_

Что выведет на экран этот код?
```c
printf("%d", 990 > 33 * 31);
```
(подсказка для любителей устного счета: легко перемножить 33 и 30) 

___Ответ:___
```
0
```


---

- _6/15_

Выберите все истинные условия, и только их.

___Ответ:___
```
4>3
(44 > 99) || (99 > 44)
```


---

- _7/15_

Выберите все истинные условия, и только их.

___Ответ:___
```
(1 < 3) > 0
1 && 9
0 || 9
```


---

- _9/15 Ошибка control reaches the end of non-void function_

__Упражнение.__ Перепишите код в задании так, чтобы он компилировался. В тестах вводятся два неотрицательные числа: первое проверяется с помощью `is_single_digit`, второе с помощью `is_double_digit`.

__Sample Input:__

1 2

__Sample Output:__

yes no

___Ответ:___
```c
// Возвращает 1 если в числе одна цифра, иначе 0
int is_single_digit(int n) {
    if (n < 0) { 
        return 0;
    } 
    if (n > 9) {
            return 0;
    }
    else {
        return 1;
    }
}

// Возвращает 1 если в числе ровно две цифры, иначе 0
int is_double_digit(int n) {
    if (n < 10) { 
        return 0;
    } 
    else {
        if (n > 99) {
            return 0;
        }
        else {
            if (n <= 99 && n >= 10) {
                return 1;
            }
            else {
                return 0;  
            }
        }
    }
}
```


---

- _11/15_

Выберите все подходящие ответы из списка

___Ответ:___
```c
print(0) && print(9)
4 < 3 || print(42) || print(88)
4 > 3 && print(10)
```


---

- _12/15_

Заполните тело функции `is_sorted3` которая принимает 3 аргумента и возвращает 1 если они в строго возрастающем порядке, -1 если они в строго убывающем порядке и 0 в остальных случаях.

__Sample Input:__

1 2 3

__Sample Output:__

1

___Ответ:___
```c
int is_sorted3(int a, int b, int c) {
    if (a < b && b < c) {
        return 1;
    } else {
        if (c < b && b < a) {
            return -1;
        } else {
            return 0;
        }
    }
}
```


---

- _13/15_

Заполните тело функции `max3` которая возвращает максимальный из своих аргументов.

Подсказка: напишите функцию `max2`, которая принимает два аргумента и возвращает максимальный из них. Можете ли вы переиспользовать эту функцию, чтобы написать функцию `max3`?

__Sample Input:__

1 2 3

__Sample Output:__

3

___Ответ:___
```c
int max2(int num1, int num2) {
    if (num1 > num2) {
        return num1;
    } else {
        return num2;
    }
}

int max3(int a, int b, int c) {
    return max2(max2(a, b), c);
}
```


---

- _14/15_

Напишите функцию `fizzbuzz`, которая принимает один аргумент типа `int` и напечатает на экран в точности одну из следующих строчек:

<blockquote>

- fizz, если аргумент положительный и делится на 3
- buzz, если аргумент положительный и делится на 5
- fizzbuzz, если аргумент положительный и делится и на 3, и на 5
- no, если аргумент меньше или равен нулю, вне зависимости от делимости.
- Во всех остальных случаях ничего выводить не нужно (например, если аргумент равен 4)

</blockquote>

Подсказка: чтобы проверить делимость числа. Используйте операцию % (остаток от деления). Если одно число делится на другое, то остаток от деления одного на другое равен нулю. Например:

```
6 % 2 == 0  // 6 делится на 2
6 % 3 == 0  // 6 делится на 3
6 % 4 == 2  // 6 не делится на 4
6 % 5 == 1  // 6 не делится на 5
6 % 6 == 0  // 6 делится на 6
```

__Sample Input:__

3

__Sample Output:__

fizz

___Ответ:___
```c
void fizzbuzz(int a) {
    if (a > 0) {
        if (a % 3 == 0) {
            printf("fizz");
        } 
        if (a % 5 == 0) {
            printf("buzz");
        }
    } else {
        printf("no");
    }
}
```

---

---

---


### 1.4 Потоки ввода и вывода


- _3/9_

Выберите все подходящие ответы из списка

___Ответ:___
```
Если мы запустили приложение в эмуляторе терминала, то вызов printf означает, что эмулятор терминала нарисует на экране какой-то текст
```


---

- _5/9_

Запустите следующий пример в OnlineGDB, введите число 4442. Скопируйте полученное число в поле ответа.

```c
// Эта функция считывает одно число со входа
// Пока нам не нужно знать, как она устроена
int read_int() {
    int x;
    scanf("%d", &x);
    return x;
}


int main() {
    printf("%d\n", read_int() ^ 0x420984ED );
    return 0;
}
```

___Ответ:___
```
1107924407
```


---

- _8/9_

Выберите все подходящие ответы из списка

___Ответ:___
```
В поток ввода можно подавать не только текст, но и любые данные
```

- 9/9

Выберите все подходящие ответы из списка

___Ответ:___
```
При запуске в эмуляторе терминала вывод по-умолчанию осуществляется через эмулятор терминала на экран
read_int считывает число со стандартного потока ввода, поэтому если в него направить файл, то можно считать число из файла
Можно соединить поток вывода одной программы с потоком ввода другой
```

---

---

---


### 1.5 Глобальные и локальные переменные

- _6/12_

Следующий код выведет на экран два числа: значения переменных a и b, разделённые пробелом. Какими будут эти значения?
```c
int a = 10;
int b = 20;

void main() {
   a = b;
   printf("a = %d b = %d", a, b);
}
```

___Ответ:___
```
a = 20 b = 20
```


---

- _7/12_

Следующий код выведет на экран два числа: значения переменных a и b, разделённые пробелом. Какими будут эти значения?

```c
int a = 10;
int b = 20;

void main() {
    b = a;
    a = b;
    printf("a = %d b = %d", a, b);
}
```

___Ответ:___
```
a = 10 b = 10
```


---

- _8/12_

Следующий код выведет на экран значения переменных `a`, `b` и `c`.
```c
int a = 10;
int b = 20;
int c = 20;

void main() {
    c = a + b;
    b = a;
    a = b + c;
    printf("a = %d b = %d c = %d", a, b, c);
}
```
Напишите в точности ту строчку, которую выведет эта программа. 

___Ответ:___
```
a = 40 b = 10 c = 30
```


---

- _10/12_

Чтобы получить 1 балл, просто запустите пример использования `read_int`:

___Ответ:___
```c
int main() {
  int input1 = read_int(); // читаем первое число
  int input2 = read_int(); // читаем второе число

  printf("%d", input1 + input2); // печатаем сумму  

  return 0;   
}
```


---

- _11/12_

В этом задании мы найдем количество корней квадратного уравнения.

Квадратным называют уравнение вида _ax&sup2; + bx + c = 0_, где _a &ne; 0._

Мы ограничимся случаем, когда _a, b, c_ - целые числа (в общем случае они не обязаны быть целыми).

Чтобы понять, сколько корней у квадратного уравнения, мы считаем так называемый _дискриминант_.

Дискриминант обозначается _D_ и равен _D = b&sup2; - 4ac._

В зависимости от значения _D_ возможны три ситуации:
<blockquote>

- если дискриминант отрицательный, то корней у уравнения нет;
- если дискриминант равен нулю, то корень ровно один;
- если дискриминант положителен, то уравнение имеет два различных корня.
</blockquote>
Вам необходимо определить три новые функции:
<blockquote>

- Функция `discriminant` принимает числа _a, b, c_ через аргументы и возвращает значение дискриминанта, подсчитанное по формуле выше.
- Функция `root_count`, принимает числа _a, b, c_ через свои аргументы и возвращает количество корней квадратного уравнения _ax&sup2; + bx + c = 0_. Она не должна печатать ничего на экран, только вернуть 0, 1 или 2. <br>
Используйте локальную переменную чтобы не подсчитывать дискриминант больше одного раза.
- Функция `main` считывает числа _a, b, c_ от пользователя (см. предыдущий слайд), с помощью `root_count` считает количество корней и выводит его на экран.
</blockquote>
Заполните пропуски в шаблоне в соответствии с комментариями.

__Обратите внимание:__ в C нет оператора "возведения в степень". Оператор ^ означает [побитовое исключающее ИЛИ](https://ru.wikipedia.org/wiki/Битовая_операция#Исключающее_ИЛИ), поэтому запись `x^2` возможна, но означает не возведение в степень, а битовую операцию.

__Sample Input:__

6 11 -35

__Sample Output:__

2

___Ответ:___
```c
int discriminant(int a, int b, int c) {
    return b*b-4*a*c;
}

int root_count(int a, int b, int c) {
   int D = discriminant(a, b, c);
   if (D > 0) {
       return 2;
   } else if (D == 0) {
       return 1;
   } else {
       return 0;
   }
}

int main() {
    // Считайте три числа в локальные переменные (см. предыдущий шаг)
    int a = read_int();
    int b = read_int();
    int c = read_int();
    // выведите результат запуска root_count с аргументами a, b и c.
    printf("%d", root_count(a, b, c));
    return 0;
}
```

---

---

---


### 1.6 Циклы

- _2/8_

Решите задачу в соответствии с указаниями в комментариях. Вам доступна функция `int read_int()`.

__Sample Input:__

1

__Sample Output:__

1 2 3 4 5 6 7 8 9 10

___Ответ:___
```c
void loop(int i) {
    if (i > 10) {
        printf("No");
    } else {
        while (i <= 10) {
            printf("%d ", i);
            i++;
        }
    }
}

int read_int() {
    int res = 0; 
    scanf("%d", &res);
    return res; 
}

int main() {
    /* - прочитайте одно число i с помощью read_int
       - используя цикл while выведите числа от i до 10 включительно;
         после каждого числа должен стоять один пробел
       - если i > 10, выведите одно слово "No"
    */
    int i = read_int();
    loop(i);
    return 0;
}
```


---

- _4/8_

Напишите функцию `is_square`, которая принимает число в качестве аргумента. Она должна возвращать 1 если число является квадратом, и 0 в противном случае.

Например, 9 является квадратом, т.к. 3&sup2; = 9, а 6 не является квадратом, т.к. не существует такого натурального числа _n_, что _n&sup2; = 6_.

Не забудьте, что 0 и 1 тоже квадраты; отрицательные числа квадратами не являются.

__Sample Input:__

16

__Sample Output:__

1

___Ответ:___
```c
int is_square(int a) {
    int i = 0;
    while (i*i <= a) {
        if (i*i == a) {
            return 1;
        } else {
            i++; 
        } 
    }
    return 0;
}
```


---

- _6/8_

Для чисел от 1 до 100 включительно выведите их делители большие 1 в порядке возрастания. Вывод начинается так:

```
1:
2: 2
3: 3
4: 2 4
5: 5
6: 2 3 6
...
```
После каждого делителя должен быть пробел, в том числе в конце строки.

___Ответ:___
```c
/* Возвращает 1 если a делится на b
  (остаток от деления a на b -- ноль)
   0 если не делится.
*/
int divides(int a, int b) { 
    return a % b == 0; 
}

/* Переводит вывод на новую строку. 
*/
void print_newline() { 
    printf("\n"); 
}

/* Выводит одну строчку: число n, двоеточие и все его делители, большие единицы, до самого n включительно.
Например, для числа 8 это:
"8: 2 4 8 "
В конце этой строчки должен быть пробел.
*/
void divisors(int n) {
    printf("%d: ", n);
    for (int j = 2; j <= n; j++) {
        if (divides(n, j)) {
            printf("%d ", j);
        }
    }
    print_newline();
}

/* Выводит делители для всех чисел от 1 до limit включительно
Каждая строчка -- в формате, заданном функцией divisors.
*/
void all_divisors(int limit) {
    for (int i = 1; i <= limit; i++) {
        divisors(i);
    }
}


int main() {
    all_divisors(100);
    return 0;
}
```


---

- _8/8_

_Простое_ число - это __положительное__ число, большее единицы, которое делится только на 1 и на само себя.

Напишите функцию `is_prime`, которая принимает через аргументы число и проверяет его на простоту. Функция должна вернуть 1 если число простое, или 0 в противном случае.

Функция должна корректно работать для любых знаковых чисел; на вход могут подать любое число, в том числе отрицательное.

__Sample Input:__

13

__Sample Output:__

1

___Ответ:___
```c
int divides(int a, int b) { 
    return a % b == 0; 
}

int is_prime(int a) {
    if (a <= 1) { 
        return 0;
    } else {
        for (int i = 2; i < a; i++) {
            if (divides(a, i)) {
                return 0;
            } else { 
                continue; 
            }
        }
        return 1;
    }
}
```

---

---

---

### 1.7 Массивы и указатели

- _2/16 Гуляем по памяти_

__Упражнение.__ Для примера рассмотрим состояние памяти после выделения следующих переменных:
```
int  x = 10;
int* p = &x;
```
Допустим, что `x` находится по адресу 1016, а `p` по адресу 2056. Можно изобразить это следующим образом:

![image](https://github.com/VeraKasianenko/VeraKasianenko/assets/112972833/bfa968c7-891e-4bd0-b1dc-4eb39e607c3f)

Впишите в пропуски, чему равно значение соответствующего выражения.

___Ответ:___
```
x == 10
&x == 1016
&p == 2056
p == 1016
*p == 10
```


---

- _4/16_

Напишите функцию `swap`, которая принимает два указателя на переменные типа `int` и меняет значения этих переменных местами.

Пример ее использования:

```c
// для примера возьмем две переменные и инициализируем их какими-нибудь числами
int x = 10;
int y = 200;

swap( &x, &y ); // теперь x == 200, y == 10
```
Внимание: указатели не обязаны указывать на разные переменные.

__Sample Input:__

1 2

__Sample Output:__

2 1

___Ответ:___
```c
void swap(int* a, int* b) {
    int c = *a;
    *a = *b;
    *b = c;
}
```


---

- _5/16_

Напишите функцию `normalize`, которая принимает указатель на __неотрицательное__ число типа `int` и делит его на 2 пока оно четное и положительное.

Например, число 100 станет 25 (100 -> 50 -> 25), число 5 останется собой, число 8 превратится в 1 (8->4->2->1).

Обратите внимание на случай, когда на вход подается 0.

__Sample Input:__

100

__Sample Output:__

25

___Ответ:___
```c
void normalize(int* a) {
   while (*a > 0 && *a % 2 == 0) {
       *a = *a / 2;
   }
}
```


---

- _7/16_

Заполните тело функции, которая принимает число n и с помощью указателей заполняет два числа a и b так, что:

<blockquote>

 - Если _n_ = 1 или _n_ простое, то положим _a_ = 1, _b_ = _n_.
 - Если _n_ составное, то:

$$
\begin{cases}
    ab = n \\
    1 < a \leq b
\end{cases}
$$

и _a_ наименьший делитель _n_, больший единицы.

Иначе говоря, нужно найти первый из делителей n больших единицы и записать его через указатель `a`.

- Гарантируется, что _n_ > 0.
</blockquote>

Вот как можно будет вызвать функцию `factorize`, которую вы напишете:

```c
int var1;
int var2;

factorize(10, &var1, &var2);

// var1 == 2, var2 == 5
```

__Sample Input:__

20

__Sample Output:__

2 10

___Ответ:___
```c
void factorize( int n, int* a, int* b ) {
    *a = 1;
    *b = n;
    for (int i = 2; i <= n/2; i++) {
        if (n % i == 0) {
            *a = i;
            *b = n / i;
            return;
        }
    }
}
```


---

- _11/16_

Традиционно, есть два способа передачи массивов в функции:

1. Передать указатель на первый элемент и размер массива
2. Передать указатель на начало массива и на элемент ___сразу после последнего___. <br> В этом случае можно пройтись по массиву увеличивая указатель так, что он сначала указывает на первый элемент, затем на второй, и так далее. Когда мы дошли до указателя __за последним элементом__, можно остановиться. <br> Почему передается не указатель на последний элемент, а сразу за ним? Это позволяет передавать массивы нулевой длины:  для них указатель на начало массива будет равен указателю на элемент "сразу за последним".

Напишите две функции, которые переворачивают массив, принимая его первым и вторым способом. В перевернутом массиве элементы идут в обратном порядке, например, массив `10 24 3 4 5` станет `5 4 3 24 10`. Изменить нужно тот массив, который функция получает в качестве аргумента; его не нужно выводить.

___Ответ:___
```c
void array_reverse(int* array, int size) {
    for (int i = 0; i < size / 2; i++) {
        int temp = array[i];
        array[i] = array[size - 1 - i];
        array[size - 1 - i] = temp;
    }
}

void array_reverse_ptr(int* array, int* limit) {
    while (array < --limit) { 
        int temp = *array;
        *array++ = *limit;  
        *limit = temp;
    }
}
```


---

- _12/16_

Напишите функцию `array_fib`, которая заполнит массив числами Фибоначчи по порядку.

Функция принимает на вход два аргумента: указатель на начало массива `array` и указатель на элемент сразу после последнего `limit` (см. предыдущий шаг).

Массив нужно заполнить так: первыми двумя числами будут 1 и 1, а каждое следующее является суммой двух предыдущих:

1 1 2 3 5 8 13 ...

Помните, что в массиве может быть любое количество чисел, даже ноль.

___Ответ:___
```c
void array_fib(int* array, int* limit) {
    int a = 1, b = 1;
    int* current = array;

    while (current < limit) {
        *current = a;
        int next = a + b;
        a = b;
        b = next;
        current++;
    }
}
```


---

- _13/16 Наращиваем уровни косвенности_

Рассмотрим состояние памяти после выделения следующих переменных:

```
int   x  = 10;
int*  p  = &x;
int** pp = &p;
```
Допустим, что `x` находится по адресу 1016, `p` по адресу 2056, `pp` по адресу 8000. Можно изобразить это следующим образом:

![image](https://github.com/VeraKasianenko/VeraKasianenko/assets/112972833/748ff618-7ead-481d-adce-79b8ad704b0d)

Впишите в пропуски, чему равно значение соответствующего выражения.

___Ответ:___
```c
&p == 2056
&pp == 8000
pp == 2056
*pp == 1016
**pp == 10
pp[0] == 1016
pp[0][0] == 10
*pp[0] == 10
```


---

- _14/16_

Теперь мы увидим типичную ситуацию, при которой функция принимает указатель на указатель. Зачем тут два уровня косвенности?

Иногда из функции нужно вернуть указатель, но возвращать его через `return` неудобно. Рассмотрим функцию `array_min`, которая находит адрес минимального числа в массиве.

```c
// min -- адрес указателя на минимальный элемент в массиве 
// функция возвращает 0 если массив пустой
int array_min(int* array, int* limit, int** min) {
    if (array >= limit) return 0;
    *min = array;
    for( int* cur = array + 1;
              cur < limit; 
              cur = cur + 1 )
    {
       if ( *cur < **min ) {
            *min = cur;
       }
    }
    return 1;
}


int main() {
    int array[] = {4,29,42,2,3};
    int* lmin = NULL;
    // только в том месте, где объявлен массив, мы можем вычислить его длину
    // sizeof(array) вернет длину в байтах
    // sizeof(array[0]) или sizeof(int) -- размер одного элемента
    
    if ( array_min( array, 
                    array + sizeof(array)/sizeof(array[0]), 
                    &lmin ) )
    {
        printf("Min is: %d\n", *lmin );
    } 
    else
    {
        printf("Array is empty\n");
    }
    return 0;
}
```

Минимальный элемент есть только в непустых массивах, поэтому нам надо предусмотреть две ситуации:
<blockquote>

- массив пустой, тогда минимума не существует.
- массив непустой, тогда вернём минимальный элемент.
</blockquote>

Если мы просто будем возвращать минимальный элемент из функции, мы не сможем сигнализировать о том, что массив был пустым. Чтобы передать в вызывающую функцию больше информации, мы будем возвращать только число типа `int`:
<blockquote>

- ноль (ложь), если минимума не существует
- один (истину), если минимум существует. В том случае нам также необходимо передать в вызывающую функцию указатель на минимальный элемент массива. Тип этого указателя `int*`.  Как это сделать, если возвращаемое значение уже занято?
</blockquote>
В примере функция `array_min` вызывается из функции main. Создадим в ней переменную `int* lmin`, в которую должен попасть указатель на минимальный элемент массива. Чтобы перезаписать `lmin`  через указатель нужно передать адрес lmin в функцию array_min; адрес lmin имеет тип int**. Отсюда и аргумент `array_min`: `int** min`.

Иными словами, `int** min` это адрес, по которому нужно записать указатель на минимальный элемент массива.

__Упражнение.__ Вам дана функция `predicate`, чью реализацию вы не знаете; вы можете только её вызывать. Вы знаете, что она принимает число и возвращает 0 или 1. Напишите функцию `array_contains`, которая найдёт первый элемент в массиве, который удовлетворяет условию `predicate`.  Как и функция array_min из примера, функция array_contains возвращает 1 если элемент найден, 0 если не найден. Кроме того, через указатель `int** position` она должна вернуть адрес найденного элемента.

___Ответ:___
```c
// position -- адрес указателя на первый элемент E в массиве,
// для которого predicate(E) выполняется.
// Функция возвращает 0 если элемент не найден.
int array_contains(int* array, int* limit, int** position) {
    if (array >= limit) return 0;
    for (int* cur = array; cur < limit; cur++) {
        if (predicate(*cur)) {
            *position = cur;
            return 1;
        }
    }
    return 0;
}
```


---

- _16/16 Строки_

Напишите функции:
<blockquote>

- `string_count`: считает длину строки в байтах (не включая нуль-терминатор)
- `string_words`: считает количество слов в строке.
</blockquote>
Между словами стоит произвольное количество пробельных символов:
<blockquote>

- пробела `' '`
- табуляции `'\t'`
- перевода строки `'\n'`
</blockquote>

Пробельные символы также могут стоять в начале или конце строки; __не гарантируется__, что в строке будет хотя бы один символ или хотя бы одно слово.

__Sample Input:__

hello  world

__Sample Output:__

length: 12 words: 2

___Ответ:___
```c
int is_whitespace(char c) { return c == ' ' || c == '\t' || c == '\n'; }

int string_count(char* str) {
    int count = 0;
    while (str[count] != '\0') {
        count++;
    }
    return count;
}

int string_words(char* str) {
    int count = 0;
    bool inside_word = false;

    while (*str) {
        if (!is_whitespace(*str)) {
            if (!inside_word) {
                inside_word = true;
                count++;
            }
        } else {
            inside_word = false;
        }
        str++;
    }
    return count;
}
```

---

---

---


### 1.8 Структура кода

- _2/13_
Опишите прототип для функции `sum`, которая принимает два указателя на целые числа и одно число, и ничего не возвращает.

___Ответ:___
```c
void sum(int*, int*, int);
```


---

- _6/13_

Напишите содержимое файла stack.h который позволит использовать в файле main.c функции `stack_push`, `stack_pop`, но не функцию `stack_full` или `stack_empty` из файла stack.c.

___Ответ:___
```c
int stack_push( int value );
int stack_pop( int* value );
```


---

- _11/13_

Напишите содержимое заголовочного файла с Include Guard. В качестве имени символа препроцессора используйте ARITH_H.

Внутри объявите функцию `sum`, возвращающую `int` и принимающую массив целых чисел и целое число.

___Ответ:___
```c
#ifndef ARITH_H
#define ARITH_H

int sum(int[], int);

#endif
```
