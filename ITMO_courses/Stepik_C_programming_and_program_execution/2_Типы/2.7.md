# 2.7 Функции высшего порядка
## _2/8_

Функция `foreach` запускает функцию-аргумент на всех элементах списка по очереди, в цикле. Реализуйте её, а затем с её помощью реализуйте `list_print`. Напоминаем, что эта функция выводит список, и после каждого элемента добавляет пробел.

### ___Ответ:___

```c
/*
struct list {
    int64_t value;
    struct list* next;
};
*/
void print_int64(int64_t i);


/* Запустить функцию f на каждом элементе списка  */
void list_foreach(struct list const* l, void (f)(int64_t)) {
    const struct list* current = l;
    while (current != NULL) {
        f(current->value);
        current = current->next;
    }
}

/* Вывести список с помощью foreach и дополнительной функции */
void list_print(struct list const* l) {
    list_foreach(l, print_int64_space);
}
```

---


## _3/8_

Функция `map_mut` запускает функцию-аргумент на всех элементах списка и перезаписывает их. Реализуйте её, а затем с её помощью реализуйте `list_triple`, умножающий каждый элемент списка на 3.

### ___Ответ:___

```c
/*
struct list {
    int64_t value;
    struct list* next;
};
*/

/* Изменить каждый элемент списка с помощью функции f  */
void list_map_mut(struct list* l, int64_t (*f)(int64_t)) {
    struct list* current = l;
    while (current != NULL) {
        current->value = f(current->value);
        current = current->next;
    }
}

static int64_t triple(int64_t x) { return x * 3; }

/* Используя list_map_mut умножьте все элементы списка на 3 */
void list_triple(struct list* l) {
    list_map_mut(l, triple);
}
```

---

## _4/8_

Функция `map` запускает функцию-аргумент на всех элементах списка и таким образом формирует новый список. Старый список остаётся нетронутым. Реализуйте `map`, а затем с её помощью реализуйте `list_copy`, копирующий список как есть, и `list_abs`, берущий модуль всех чисел в списке.

### ___Ответ:___

```c
/*
struct list {
    int64_t value;
    struct list* next;
};
*/
/* Вы можете пользоваться следующими функциями */
void print_int64(int64_t i);
struct list* node_create( int64_t value );



/*  Создать новый список, в котором каждый элемент получен из соответствующего
    элемента списка l путём применения функции f */
struct list* list_copy(struct list const* l) {
    struct list* new_list = NULL;
    struct list** ptr = &new_list;

    while (l != NULL) {
        *ptr = node_create(l->value);
        ptr = &((*ptr)->next);
        l = l->next;
    }

    return new_list;
}

void list_map_mut(struct list* l, int64_t (*f)(int64_t)) {
    while (l != NULL) {
        l->value = f(l->value);
        l = l->next;
    }
}

struct list* list_map(struct list const* l, int64_t (*f)(int64_t)) {
    struct list* l_copy = list_copy(l);
    list_map_mut(l_copy, f);
    return l_copy;
}

struct list* list_abs(struct list const* l) {
    return list_map(l, labs);
}
```

---

## _7/8_

Теперь реализуем функцию `fold`, которая сворачивает список так же, как мы делали с массивом.

### ___Ответ:___

```c
/*
struct list {
    int64_t value;
    struct list* next;
};
*/
/* Вы можете пользоваться этими функциями */
void print_int64(int64_t i);
struct list* node_create( int64_t value );
void list_destroy( struct list* list );

static int64_t sum( int64_t x, int64_t y) { return x + y; }

typedef int64_t folding(int64_t, int64_t);

/* Свернуть список l с помощью функции f. */
int64_t list_fold(struct list const* l, int64_t init, folding f) {
    while (l != NULL) {
        init = f(init, l->value);
        l = l->next;
    }
    return init;
}

/* Просуммируйте список с помощью list_fold и sum */
int64_t list_sum(const struct list* l) {
    return list_fold(l, 0, sum);
}
```

---

## _8/8_

Наконец, напишем функцию `iterate`, которая сгенерирует список применяя функцию к первому элементу 0, 1, 2 раза и т.д. пока список не достигнет требуемой длины.

Например, возьмём функцию _f(x) = 3x_. Положим начальный элемент равным 2. Тогда список из пяти элементов будет выглядеть так: 2, 6, 18, 54, 162.

### ___Ответ:___

```c
/*
struct list {
    int64_t value;
    struct list* next;
};
*/
void print_int64(int64_t i);

struct list* node_create( int64_t value );
void list_destroy( struct list* list );


/*  Сгенерировать список длины sz с помощью значения init и функции f
 Результат: init, f(init), f(f(init)), ... */
struct list* list_iterate(int64_t init, size_t sz, int64_t (f)(int64_t)) {
    if (sz == 0) return NULL;

    struct list* list = node_create(init);
    struct list* ptr = list;

    for (size_t i = 1; i < sz; ++i) {
        ptr->next = node_create(f(ptr->value));
        ptr = ptr->next;
    }

    return list;
}
```
