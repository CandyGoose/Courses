# 2.6 Функции
## _3/11_

С помощью `typedef` определите тип `ftype` функции, которая принимает два аргумента:
- `const float*`
- (указатель на) функцию, принимающую `struct array` и `int64_t` и возвращающую `size_t`

и возвращает `char`.

Ваше определение должно позволять написать:
```c
ftype* fptr = f;
```
где `f` это функция с подходящей сигнатурой.

### ___Ответ:___

```c
// используйте typedef чтобы определить ftype
typedef char func(struct array, int64_t);
typedef char ftype(const float*, func*);
```

---

## _9/11_

Используйте функцию `qsort` чтобы отсортировать массив структур по разным полям этих структур.

### ___Ответ:___

```c
// Мы хотим, чтобы в структуре user хранились ссылки только на строчки из кучи.
typedef struct { char* addr; } string_heap ;

/*  Тип для идентификаторов пользователей
    и его спецификаторы ввода и вывода для printf */
typedef uint64_t uid;
#define PRI_uid PRIu64
#define SCN_uid SCNu64

enum city {C_SARATOV, C_MOSCOW, C_PARIS, C_LOS_ANGELES, C_OTHER};

/*  Массив, где элементам перечисления сопоставляются их текстовые представления */
const char* city_string[] = {
  [C_SARATOV] = "Saratov",
  [C_MOSCOW] = "Moscow",
  [C_PARIS] = "Paris",
  [C_LOS_ANGELES] = "Los Angeles",
  [C_OTHER] = "Other"
};


struct user {
  const uid id;
  const string_heap name;
  enum city city;
};

int compare_users_uid(const void *a, const void *b) {
    const struct user *user_a = (const struct user *)a;
    const struct user *user_b = (const struct user *)b;
    if (user_a->id < user_b->id) return -1;
    if (user_a->id > user_b->id) return 1;
    return 0;
}

int compare_users_name(const void *a, const void *b) {
    const struct user *user_a = (const struct user *)a;
    const struct user *user_b = (const struct user *)b;
    return strcmp(user_a->name.addr, user_b->name.addr);
}

int compare_users_city(const void *a, const void *b) {
    const struct user *user_a = (const struct user *)a;
    const struct user *user_b = (const struct user *)b;
    return strcmp(city_string[user_a->city], city_string[user_b->city]);
}

/* Сортировать массив пользователей по полю uid по возрастанию */
void users_sort_uid(struct user users[], size_t sz) {
    qsort(users, sz, sizeof(struct user), compare_users_uid);
}

/* Сортировать массив пользователей по полю name */
/* Порядок строк лексикографический; можно использовать компаратор 
   строк -- стандартную функцию strcmp */
void users_sort_name(struct user users[], size_t sz) {
    qsort(users, sz, sizeof(struct user), compare_users_name);
}

/* Сортировать массив по _текстовому представлению_ города */
void users_sort_city(struct user users[], size_t sz) {
    qsort(users, sz, sizeof(struct user), compare_users_city);
}
```

---

## _11/11_

В реальных программах у событий может быть множество обработчиков. Давайте реализуем такую систему, где можно навесить сколько угодно обработчиков на каждое событие!

Представим, что мы управляем роботом, который может перемещаться вперёд, вниз, влево или вправо. Когда робот начинает ехать в определённом направлении, это событие! В момент события робот вызывает функцию `move(dir)`, где `dir` это направление движения. При этом должны вызваться все обработчики движения.

Мы хотим иметь возможность в любой момент добавить ещё реакций на  код, который робот вызовет в этот момент.

Подсказка: массивы указателей на функции для этого не подойдут, так как у массивов фиксированный размер, но можно сделать список указателей!

### ___Ответ:___

```c
enum move_dir { MD_UP, MD_RIGHT, MD_DOWN, MD_LEFT, MD_NONE };

// Определите тип обработчика событий move_callback с помощью typedef
typedef void (*move_callback)(enum move_dir);

struct list {
    move_callback value;
    struct list* next;
};

// Робот и его callback'и
// callback'ов может быть неограниченное количество
struct robot {
    const char* name;
    struct list* callbacks;
};

struct list* node_create(move_callback value) {
    struct list* node = malloc(sizeof(struct list));
    node->value = value;
    node->next = NULL;
    return node;
}

void list_add_front(struct list** old, move_callback value) {
    struct list* new = node_create(value);
    new->next = *old;
    *old = new;
}

void list_destroy(struct list* list) {
    while (list != NULL) {
        struct list* current = list;
        list = list->next;
        free(current);
    }
}

// Добавить callback к роботу, чтобы он вызывался при движении
// В callback будет передаваться направление движения
void register_callback(struct robot* robot, move_callback new_cb) {
    list_add_front(&(robot->callbacks), new_cb);
}

// Отменить все подписки на события.
// Это нужно чтобы освободить зарезервированные ресурсы
// например, выделенную в куче память
void unregister_all_callbacks(struct robot* robot) {
    list_destroy(robot->callbacks);
    robot->callbacks = NULL;
}

// Вызывается когда робот движется
// Эта функция должна вызвать все обработчики событий
void move(struct robot* robot, enum move_dir dir) {
    struct list* ptr = robot->callbacks;
    while (ptr != NULL) {
        (ptr->value)(dir);
        ptr = ptr->next;
    }
}
```
